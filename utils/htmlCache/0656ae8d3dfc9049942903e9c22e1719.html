<!DOCTYPE html><html><head><title>[译] 揭秘 iOS 布局-社区博客-网易云</title><meta charset="utf-8"><meta name="keywords" content=""/><meta name="description" content=""/><link rel="canonical" href="https://sq.163yun.com/blog/article/200743376636538880" /><link rel="shortcut icon" href="/favicon.ico"><meta name="baidu-site-verification" content="no5d5j0fvZ" /><meta name="google-site-verification" content="vfKghSUszSNX0H0xShpovztalmHUieHty9QTaYO7r1Q" /><link href="/assets/css/blog/article.css?e66f8211b5d927468305" rel="stylesheet"></head><body><!--[if lt IE 9]><script type="text/javascript">(function() {if (!/*@cc_on!@*/0) return;var e = "abbr, article, aside, audio, canvas, datalist, footer, header, menu, nav, section, video".split(', ');var i= e.length;while (i--){document.createElement(e[i])}})()</script><![endif]--><div class="g-doc"><header><div class="m-hd f-cb"><a href="https://www.163yun.com" class="logo" target="_blank"><img src="/assets/img/common/logo.png" srcset="/assets/img/common/logo.png 1x, /assets/img/common/logo@2x.png 2x"/></a><ul class="nav f-cb"><li><a href="/blog" class="act">博客</a></li><li><a href="/topic" >专题</a></li><li><a href="/ask" >问答</a></li><li><a href="/download" >资源下载</a></li></ul><div class="opt f-cb f-fr"><div class="m-search m-search-2 f-cb f-ib" id="search-box"><input type="text" placeholder="搜索需要查询的内容" maxlength="256" class="u-ipt j-searchword" value=""/><i class="icon-search j-search"></i></div><div id="login-box" class="login-box f-ib"><span class="j-login" id="login">登录</span><span id="register" class="j-register u-btn-j">注册</span></div></div></div></header><div class="g-bd"><div class="g-bd-main f-cb"><div class="g-bd-r"><div class="m-hot-personal"><div class="u-per-img"><a href="/user/187751371929571328" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/20180917172954a6deadc6-7966-4dde-a107-61728de1a3f9.jpg"/></a></div><div class="u-per-ntblog"><p class="u-info-nickname"><a href="/user/187751371929571328" target="_blank">叁叁肆</a></p><p class="u-info-sign">这个世界会好吗</p><p class="u-info-blognum">454篇博客</p></div></div><div class="m-hot-common"><h2><img class="u-pop-img" src="/assets/img/cms/icon_rmbk.png" srcset="/assets/img/cms/icon_rmbk.png 1x, /assets/img/cms/icon_rmbk@2x.png 2x"/><span>最新博客</span></h2><ul class=""><li><span class="left-spot"></span><a href="/blog/article/254318557017464832" target="_blank" class="u-jump-page">2019年微服务5大趋势，你pick哪个？</a></li><li><span class="left-spot"></span><a href="/blog/article/233379497714626560" target="_blank" class="u-jump-page">LinkedBlockingQueue源码解析（3）</a></li><li><span class="left-spot"></span><a href="/blog/article/233378864209158144" target="_blank" class="u-jump-page">LinkedBlockingQueue源码解析（2）</a></li><li><span class="left-spot"></span><a href="/blog/article/233378597564669952" target="_blank" class="u-jump-page"> LinkedBlockingQueue源码解析（1）</a></li><li><span class="left-spot"></span><a href="/blog/article/233374848683171840" target="_blank" class="u-jump-page">企业项目开发--本地缓存guava cache（2）</a></li><li><span class="left-spot"></span><a href="/blog/article/233374411930296320" target="_blank" class="u-jump-page">企业项目开发--本地缓存guava cache（1）</a></li><li><span class="left-spot"></span><a href="/blog/article/233373951968129024" target="_blank" class="u-jump-page"> AtomicInteger源码解析</a></li><li><span class="left-spot"></span><a href="/blog/article/233356094221934592" target="_blank" class="u-jump-page">Google guava cache源码解析1--构建缓存器（3）</a></li><li><span class="left-spot"></span><a href="/blog/article/233355704088748032" target="_blank" class="u-jump-page">Google guava cache源码解析1--构建缓存器（2）</a></li><li><span class="left-spot"></span><a href="/blog/article/233354570208993280" target="_blank" class="u-jump-page">Google guava cache源码解析1--构建缓存器（1）</a></li></ul></div><div class="m-hot-common"><h2><img class="u-pop-img" src="/assets/img/resource/icon_res.png" srcset="/assets/img/resource/icon_res.png 1x, /assets/img/resource/icon_res@2x.png 2x"/><span>最新资源下载</span></h2><ul class="item-res"><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234105167433945088&fileId=239479055048691712"target="_blank"rel="noopener">微服务框架在多个行业的架构设计与落地实践</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234105428109938688&fileId=239478966523711488"target="_blank"rel="noopener">微服务系统设计实践</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234105523295473664&fileId=239478426188304384"target="_blank"rel="noopener">微服务实践痛点与解决方案</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=235473901836226560&fileId=235473894722686976"target="_blank"rel="noopener">网易云：技术驱动·产品为王-汪源</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234391172239511552&fileId=234391115117285376"target="_blank"rel="noopener">新形势下的互联网安全攻与防_CNCERT_20180413</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234391055486865408&fileId=234391022951649280"target="_blank"rel="noopener">安卓App安全过检实践 - 网易云 朱星星</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234390994728177664&fileId=234390927527038976"target="_blank"rel="noopener">UGC产品如何规避运营风险</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234390893171494912&fileId=234390800158609408"target="_blank"rel="noopener">电商风控运营背后的故事</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234389422728204288&fileId=234389358563741696"target="_blank"rel="noopener">开放技术打造企业未来之路--汪源</a></li><li><span class="left-spot"></span><a class="download-box u-jump-page"href="/resource/download?id=234387974158209024&fileId=234387901408006144"target="_blank"rel="noopener">网易在线教育生态-孙志岗</a></li></ul></div><div class="m-right-edit"><h2 class="m-right-title"><img class="u-pop-img" src="/assets/img/cms/blog_home_icon_bjtj.png" srcset="/assets/img/cms/blog_home_icon_bjtj.png 1x, /assets/img/cms/blog_home_icon_bjtj@2x.png 2x"/><span>编辑推荐</span></h2><div class="m-right-editpage"><a class="u-public-switch u-public-padding" href="https://sq.163yun.com/blog/article/236020725847420928" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/201812260945090bd2ce50-36c6-4466-868b-19054cee88ef.jpeg"/><span class="u-pop-desc"><span  title="一网打尽！2018网络安全事件最全的盘点">一网打尽！2018网络安全事件最全的盘点</span></span></a><a class="u-public-switch u-public-padding" href="https://sq.163yun.com/blog/article/233678273004154880" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/2018122009313111d20f02-c147-4863-83a2-c076287d6c22.jpeg"/><span class="u-pop-desc"><span  title="Facebook内部报告：争取青少年用户的鸡贼小技巧">Facebook内部报告：争取青少年用户的鸡贼小技巧</span></span></a><a class="u-public-switch u-public-padding" href="https://sq.163yun.com/blog/article/233763151645224960" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/20181120091204c361f71d-427b-4dee-a0fc-3fe7bd362602.jpeg"/><span class="u-pop-desc"><span  title="企业项目开发--maven父子模块（1）">企业项目开发--maven父子模块（1）</span></span></a><a class="u-public-switch u-public-padding" href="https://sq.163yun.com/blog/article/227915414915784704" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/2018120409274734052ed1-d82c-4354-a09a-f84e974c003e.jpeg"/><span class="u-pop-desc"><span  title="【译文】东京的外国工程师">【译文】东京的外国工程师</span></span></a><a class="u-public-switch u-public-padding" href="https://sq.163yun.com/topic/detail/226455935984644096" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/2018113010225113053d13-e666-425c-8cc1-48401505c261.jpeg"/><span class="u-pop-desc"><span  title="HBase最佳实践">HBase最佳实践</span></span></a><a class="u-public-switch u-public-padding" href="https://sq.163yun.com/blog/article/226138187322187776" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/20181126092218c946c64d-22ff-4f4f-add5-81c5225b96c6.jpeg"/><span class="u-pop-desc"><span  title="手滑把库给删了，跑路前应该做的事。。。">手滑把库给删了，跑路前应该做的事。。。</span></span></a></div></div></div><div class="g-bd-l"><div class="m-detail"><h1 class="tlt">[译] 揭秘 iOS 布局</h1><div class="m-information"><div class="m-info f-cb"><a href="/user/187751371929571328" class="f-cb" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/20180917172954a6deadc6-7966-4dde-a107-61728de1a3f9.jpg"/><span>叁叁肆</span></a><span class="time-blog">2018-09-19 13:51</span></div><div class="opt f-cb" style="display: none;" data-id="187751371929571328" id="blog-opt"><a class="u-btn f-fl" href="/blog/modify/200743376636538880">修改</a><button class="u-btn u-btn-m f-fl mr10" id="btn-del">删除</button></div></div><div class="cnt m-md-result"><p>本文来自网易云社区<span></span></p> 
<p>作者：宋申易</p> 
<p><b><br></b></p> 
<p>翻译自：<a href="http://tech.gc.com/demystifying-ios-layout/"><u><font>Demystifying iOS Layout</font></u></a></p> 
<p><span> <br></span></p> 
<p>在你刚开始开发 iOS 应用时，最难避免或者是调试的就是和布局相关的问题。通常这种问题发生的原因就是对于 view 何时真正更新的错误理解。想理解 view 在何时是如何更新的，需要对 iOS RunLoop 和相关的 <code>UIView</code> 方法有深刻的理解。这篇文章会介绍这些关联，希望能帮你澄清如何用 <code>UIView</code> 的方法来获得正确的行为。</p> 
<p><span> <br></span></p> 
<h2>一个 iOS 应用的主 RunLoop<span></span></h2> 
<p>一个 iOS 应用的主 RunLoop 负责处理所有的用户输入事件并触发相应的响应。所有的用户交互都会被加入到一个事件队列中。下图中的 <code>Application</code> object 会从队列中取出事件并将它们分发到应用中的其他对象上。本质上它会解释这些来自用户的输入事件，然后调用在应用中的 Core objects 相应的处理代码，而这些代码再调用开发者写的代码。当这些方法调用返回后，控制流回到主 RunLoop 上，然后开始 <em>update cycle（更新周期）</em>。Update cycle 负责布局并且重新渲染视图们（接下来会讲到）。下面的图片展示了应用是如何和设备交互并且处理用户输入的。</p> 
<p> <img src="https://nos.netease.com/cloud-website-bucket/2018091913500737f469c3-1b62-4c97-bdb6-132deae5fcb6.jpg"><span></span></p> 
<p><em><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html"><u><font>https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html</font></u></a></em></p> 
<p><span> <br></span></p> 
<h2>Update Cycle<span></span></h2> 
<p>Update cycle 是当应用完成了你的所有事件处理代码后控制流回到主 RunLoop 时的那个时间点。正是在这个时间点上系统开始更新布局、显示和设置约束。如果你在处理事件的代码中请求修改了一个 view，那么系统就会把这个 view 标记为需要重画（redraw）。在接下来的 Update cycle 中，系统就会执行这些 view 上的更改。用户交互和布局更新间的延迟几乎不会被用户察觉到。iOS 应用一般以 60 fps 的速度展示动画，就是说每个更新周期只需要 1/60 秒。这个更新的过程很快，所以用户在和应用交互时感觉不到 UI 中的更新延迟。但是由于在处理事件和对应 view 重画间存在着一个间隔，RunLoop 中的某时刻的 view 更新可能不是你想要的那样。如果你的代码中的某些计算依赖于当下的 view 内容或者是布局，那么就有在过时 view 信息上操作的风险。理解 RunLoop、update cycle 和 <code>UIView</code> 中具体的方法可以帮助避免或者可以调试这类问题。下面的图展示出了 update cycle 发生在 RunLoop 的尾部。</p> 
<p> <img src="https://nos.netease.com/cloud-website-bucket/201809191350304d3569a5-6554-4e50-b076-ba025a462829.png"></p> 
<h2><br></h2> 
<h2>布局<span></span></h2> 
<p>一个视图的布局指的是它在屏幕上的的大小和位置。每个 view 都有一个 frame 属性，用来表示在父 view 坐标系中的位置和具体的大小。<code>UIView</code> 给你提供了用来通知系统某个 view 布局发生变化的方法，也提供了在 view 布局重新计算后调用的可重写的方法。</p> 
<p><span> <br></span></p> 
<p><strong>layoutSubviews()</strong><span></span></p> 
<p>这个 <code>UIView</code> 方法处理对视图（view）及其所有子视图（subview）的重新定位和大小调整。它负责给出当前 view 和每个子 view 的位置和大小。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。系统会在任何它需要重新计算视图的 frame 的时候调用这个方法，所以你应该在需要更新 frame 来重新定位或更改大小时重载它。然而你不应该在代码中显式调用这个方法。相反，有许多可以在 run loop 的不同时间点触发 <code>layoutSubviews</code> 调用的机制，这些触发机制比直接调用 <code>layoutSubviews</code> 的资源消耗要小得多。<span></span></p> 
<p>当 <code>layoutSubviews</code> 完成后，在 view 的所有者 view controller 上，会触发 <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 view 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。这是避免使用过时的布局或者位置变量的唯一方法。</p> 
<p><span> <br></span></p> 
<p><strong>自动刷新触发器</strong><span></span></p> 
<p>有许多事件会自动给视图打上 “update layout” 标记，因此 <code>layoutSubviews</code> 会在下一个周期中被调用，而不需要开发者手动操作。这些自动通知系统 view 的布局发生变化的方式有：<span></span></p> 
<ul> 
 <li>修改 view 的大小</li> 
 <li>新增 subview</li> 
 <li>用户在 <code>UIScrollView</code> 上滚动（<code>layoutSubviews</code> 会在 <code>UIScrollView</code> 和它的父 view 上被调用）</li> 
 <li>用户旋转设备</li> 
 <li>更新视图的 constraints</li> 
 <span></span> 
</ul> 
<p>这些方式都会告知系统 view 的位置需要被重新计算，继而会自动转化为一个最终的 <code>layoutSubviews</code> 调用。当然，也有直接触发 <code>layoutSubviews</code> 的方法。</p> 
<p><span> <br></span></p> 
<p><strong>setNeedsLayout()</strong><span></span></p> 
<p>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法。调用这个方法代表向系统表示视图的布局需要重新计算。<code>setNeedsLayout</code> 方法会立刻执行并返回，但在返回前不会真正更新视图。视图会在下一个 update cycle 中更新，就在系统调用视图们的 <code>layoutSubviews</code> 以及他们的所有子视图的 <code>layoutSubviews</code> 方法的时候。即使从 <code>setNeedsLayout</code> 返回后到视图被重新绘制并布局之间有一段任意时间的间隔，但是这个延迟不会对用户造成影响，因为永远不会长到对界面造成卡顿。</p> 
<p><span> <br></span></p> 
<p><strong>layoutIfNeeded()</strong><span></span></p> 
<p><code>layoutIfNeeded</code> 是另一个会让 <code>UIView</code> 触发 <code>layoutSubviews</code> 的方法。 当视图需要更新的时候，与 <code>setNeedsLayout()</code> 会让视图在下一周期调用 <code>layoutSubviews</code> 更新视图不同，<code>layoutIfNeeded</code> 会立即调用 <code>layoutSubviews</code> 方法。但是如果你调用了 <code>layoutIfNeeded</code> 之后，并且没有任何操作向系统表明需要刷新视图，那么就不会调用 <code>layoutsubview</code>。如果你在同一个 run loop 内调用两次 <code>layoutIfNeeded</code>，并且两次之间没有更新视图，第二个调用同样不会触发 <code>layoutSubviews</code> 方法。<span></span></p> 
<p>使用 <code>layoutIfNeeded</code>，则布局和重绘会立即发生并在函数返回之前完成（除非有正在运行中的动画）。这个方法在你需要依赖新布局，无法等到下一次 update cycle 的时候会比 <code>setNeedsLayout</code> 有用。除非是这种情况，否则你更应该使用 <code>setNeedsLayout</code>，这样在每次 run loop 中都只会更新一次布局。<span></span></p> 
<p>当对希望通过修改 constraint 进行动画时，这个方法特别有用。你需要在 animation block 之前对 self.view 调用 <code>layoutIfNeeded</code>，以确保在动画开始之前传播所有的布局更新。在 animation block 中设置新 constrait 后，需要再次调用 <code>layoutIfNeeded</code> 来动画到新的状态。</p> 
<p><span> <br></span></p> 
<h2>显示<span></span></h2> 
<p>一个视图的显示包含了颜色、文本、图片和 Core Graphics 绘制等视图属性，不包括其本身和子视图的大小和位置。和布局的方法类似，显示也有触发更新的方法，它们由系统在检测到更新时被自动调用，或者我们可以手动调用直接刷新。</p> 
<p><span> <br></span></p> 
<p><strong>draw(_:)</strong><span></span></p> 
<p><code>UIView</code> 的 <code>draw</code> 方法（本文使用 Swift，对应 Objective-C 的 <code>drawRect</code>）对视图内容显示的操作，类似于视图布局的 <code>layoutSubviews</code> ，但是不同于 <code>layoutSubviews</code>，<code>draw</code> 方法不会触发后续对视图的子视图方法的调用。同样，和 <code>layoutSubviews</code> 一样，你不应该直接调用 <code>draw</code> 方法，而应该通过调用触发方法，让系统在 run loop 中的不同结点自动调用。</p> 
<p><span> <br></span></p> 
<p><strong>setNeedsDisplay()</strong><span></span></p> 
<p>这个方法类似于布局中的 <code>setNeedsLayout</code> 。它会给有内容更新的视图设置一个内部的标记，但在视图重绘之前就会返回。然后在下一个 update cycle 中，系统会遍历所有已标标记的视图，并调用它们的 <code>draw</code> 方法。如果你只想在下次更新时重绘部分视图，你可以调用 <code>setNeedsDisplay(_:)</code>，并把需要重绘的矩形部分传进去（<code>setNeedsDisplayInRect</code> in OC)。大部分时候，在视图中更新任何 UI 组件都会把相应的视图标记为“dirty”，通过设置视图“内部更新标记”，在下一次 update cycle 中就会重绘，而不需要显式的 <code>setNeedsDisplay</code> 调用。然而如果你有一个属性没有绑定到 UI 组件，但需要在每次更新时重绘视图，你可以定义他的 <code>didSet</code> 属性，并且调用 <code>setNeedsDisplay</code> 来触发视图合适的更新。<span></span></p> 
<p>有时候设置一个属性要求自定义绘制，这种情况下你需要重写 <code>draw</code> 方法。在下面的例子中，设置 <code>numberOfPoints</code> 会触发系统系统根据具体点数绘制视图。在这个例子中，你需要在 <code>draw</code> 方法中实现自定义绘制，并在 <code>numberOfPoints</code> 的 property observer 里调用 <code>setNeedsDisplay</code>。</p> 
<pre><code><span>class</span> <span>MyView</span>: <span>UIView</span> {
    <span>var</span> numberOfPoints = <span>0</span> {
        didSet {
            setNeedsDisplay()
        }
    }

    <span><span>override</span> func <span>draw</span><span>(_ rect: CGRect)</span> </span>{
        <span>switch</span> numberOfPoints {
        <span>case</span> <span>0</span>:
            <span>return</span>
        <span>case</span> <span>1</span>:
            drawPoint(rect)
        <span>case</span> <span>2</span>:
            drawLine(rect)
        <span>case</span> <span>3</span>:
            drawTriangle(rect)
        <span>case</span> <span>4</span>:
            drawRectangle(rect)
        <span>case</span> <span>5</span>:
            drawPentagon(rect)
        <span>default</span>:
            drawEllipse(rect)
        }
    }
}
</code></pre> 
<p>视图的显示方法里没有类似布局中的 <code>layoutIfNeeded</code> 这样可以触发立即更新的方法。通常情况下等到下一个更新周期再重新绘制视图也无所谓。</p> 
<span> </span> 
<h2><br></h2> 
<h2>约束</h2> 
<span> </span> 
<p>自动布局包含三步来布局和重绘视图。第一步是更新约束，系统会计算并给视图设置所有要求的约束。第二步是布局阶段，布局引擎计算视图和子视图的 frame 并且将它们布局。最后一步完成这一循环的是显示阶段，重绘视图的内容，如实现了 <code>draw</code> 方法则调用 <code>draw</code>。</p> 
<span> </span> 
<p><strong>updateConstraints()</strong></p> 
<span> </span> 
<p>这个方法用来在自动布局中动态改变视图约束。和布局中的 <code>layoutSubviews()</code> 方法或者显示中的 <code>draw</code> 方法类似，<code>updateConstraints()</code> 只应该被重载，绝不要在代码中显式地调用。通常你只应该在 <code>updateConstraints</code> 方法中实现必须要更新的约束。静态的约束应该在 interface builder、视图的初始化方法或者 <code>viewDidLoad()</code> 方法中指定。</p> 
<span> </span> 
<p>通常情况下，设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 “update constarints”，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。当然，也有手动给视图打上“update constarints” 标记的方法，如下。</p> 
<span> </span> 
<p><strong>setNeedsUpdateConstraints()</strong></p> 
<span> </span> 
<p>调用 <code>setNeedsUpdateConstraints()</code> 会保证在下一次更新周期中更新约束。它通过标记“update constraints”来触发 <code>updateConstraints()</code>。这个方法和 <code>setNeedsDisplay()</code> 以及 <code>setNeedsLayout()</code> 方法的工作机制类似。</p> 
<span> </span> 
<p><strong>updateConstraintsIfNeeded()</strong></p> 
<span> </span> 
<p>对于使用自动布局的视图来说，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 “update constraints”标记（可以被 <code>setNeedsUpdateConstraints</code> 或者 <code>invalidateInstrinsicContentSize</code>方法自动设置）。如果它认为这些约束需要被更新，它会立即触发 <code>updateConstraints()</code> ，而不会等到 run loop 的末尾。</p> 
<span> </span> 
<p><strong>invalidateIntrinsicContentSize()</strong></p> 
<span> </span> 
<p>自动布局中某些视图拥有 <code>intrinsicContentSize</code> 属性，这是视图根据它的内容得到的自然尺寸。一个视图的 <code>intrinsicContentSize</code> 通常由所包含的元素的约束决定，但也可以通过重载提供自定义行为。调用 <code>invalidateIntrinsicContentSize()</code> 会设置一个标记表示这个视图的 <code>intrinsicContentSize</code> 已经过期，需要在下一个布局阶段重新计算。</p> 
<h2><br></h2> 
<h2>它们是如何连接起来的</h2> 
<span> </span> 
<p>布局、显示和约束都遵循着相似的模式，例如他们更新的方式以及如何在 run loop 的不同时间点上强制更新。任一组件都有一个实际去更新的方法（<code>layoutSubviews</code>, <code>draw</code>, 和 <code>updateConstraints</code>），你可以重写来手动操作视图，但是任何情况下都不要显式调用。这个方法只在 run loop 的末端会被调用，如果视图被标记了告诉系统该视图需要被更新的标记的话。有一些操作会自动设置这个标志，但是也有一些方法允许您显式地设置它。对于布局和约束相关的更新，如果你等不到在 run loop 末端才更新（例如：其他行为依赖于新布局），有方法可以让你立即更新，并保证 “update layout” 标记被正确标记。下面的表格列出了任意组件会怎样更新及其对应方法。</p> 
<p><img src="https://nos.netease.com/cloud-website-bucket/201809191350518b3586dc-7fa6-40ef-807e-842c9612eee6.png"><b></b></p> 
<span> </span> 
<p></p> 
<span> </span> 
<p>下面的流程图总结了 update cycle 和 event loop 之间的交互，并指出了上文提到的方法在 run loop 运行期间的位置。你可以在 run loop 中的任意一点显式地调用 layoutIfNeeded 或者 updateConstraintsIfNeeded，需要记住，这开销会很大。在循环的末端是 update cycle，如果视图被设置了特定的 “update constraints”，“update layout” 或者 “needs display” 标记，在这节点会更新约束、布局以及展示。一旦这些更新结束，runloop 会重新启动。</p> 
<p><img src="https://nos.netease.com/cloud-website-bucket/20180919135102d2c48381-c7aa-4a02-9ec4-b1739323d12d.png"><b></b></p> 
<span> </span> 
<p></p> 
<p><font size="2"><br></font></p> 
<p><font size="2">网易云<a href="https://www.163yun.com/free#fc?tag=M_tg_234_69"><u><font>免费体验馆</font></u></a><b>，</b>0成本体验20+款云产品！</font></p> 
<p><font size="2">更多网易研发、产品、运营经验分享请访问<a href="https://sq.163yun.com/blog"><u><font>网易云社区</font></u></a>。</font></p> 
<p></p> 
<p><b></b><i></i><u></u><sub></sub><sup></sup> 
 <strike></strike><br></p></div><div class="m-share">分享至：<div class="u-icon-wechat f-ib"><img class="u-share-img" src="/assets/img/blog/blog_wechat.png" srcset="/assets/img/blog/blog_wechat.png 1x, /assets/img/blog/blog_wechat@2x.png 2x"/><div class="wechat_qrcode" id="qrcode"></div></div><a href="http://service.weibo.com/share/share.php?appkey=&title=[译] 揭秘 iOS 布局&url=http://sq.163yun.com/blog/article/200743376636538880&pic=&searchPic=false&style=simple" target="_blank" class="f-ib"><img class="u-share-img" src="/assets/img/blog/blog_weibo.png" srcset="/assets/img/blog/blog_weibo.png 1x, /assets/img/blog/blog_weibo@2x.png 2x"/></a></div><div class="next f-cb"><p class="f-fl"><a href="/blog/article/200742336935686144" class="u-jump-color"><span class="draw-light"><span class="towards-left">&lt;</span>上一篇</span><span class="draw-lights-jump">巧用ansible提高效率</span></a></p><p class="f-fr"><a href="/blog/article/200744924770922496" class="u-jump-color"><span class="draw-light">下一篇</span><span class="draw-lights-jump">[译]理解 Objective-C 运行时(下篇)</span><span class="towards-right draw-lights-jump">&gt;</span></a></p></div></div></div><div class="g-bd-bt"><div class="m-bt-ad"><a href="https://hubble.netease.com/sl/aaaayB" target="_blank"><img src="https://nos.netease.com/cloud-website-bucket/20181218155518ac935409-499c-42c5-bf20-05da0c2fe8eb.png" class="u-pic-img-full"/></a></div><div class="m-bt-recommend"><h2><img class="u-pop-img" src="/assets/img/cms/icon_rmbk.png" srcset="/assets/img/cms/icon_rmbk.png 1x, /assets/img/cms/icon_rmbk@2x.png 2x"/>推荐博客</h2><ul><li><a href="/blog/article/190903782888718336" target="_blank" class="u-jump-page">java 接口测试技巧</a></li><li><a href="/blog/article/231145817222995968" target="_blank" class="u-jump-page">双12，聊聊和电商们有关的网络安全</a></li><li><a href="/blog/article/211687494267056128" target="_blank" class="u-jump-page">MySQL MGR源码分析 - 从start group_replication看MGR代码框架</a></li><li><a href="/blog/article/241405397888745472" target="_blank" class="u-jump-page">面向一线审核人员，《网络短视频内容审核标准细则》详细内容对外公布 </a></li><li><a href="/blog/article/230829933300596736" target="_blank" class="u-jump-page">如何进行用户访谈更容易获得全面而有效的信息</a></li><li><a href="/blog/article/200386242403368960" target="_blank" class="u-jump-page">聊聊WS-Federation</a></li><li><a href="/blog/article/214116269993439232" target="_blank" class="u-jump-page">NEJ-Dispatcher剖析(二) 调度原理</a></li><li><a href="/blog/article/188805878260191232" target="_blank" class="u-jump-page">Java Synchronized JVM实现分析（下篇）</a></li><li><a href="/blog/article/186588819338055680" target="_blank" class="u-jump-page">如何实现最佳的跨平台游戏体验？Unity成亮解密实时渲染技术！ </a></li><li><a href="/blog/article/154396839568982016" target="_blank" class="u-jump-page">网易推首款运营云”七鱼”以”智能化”瞄准客服行业</a></li></ul></div></div></div></div><footer id="footer"><p>网易公司版权所有 © 1997-2018&nbsp;&nbsp;<span>·</span>&nbsp;&nbsp;增值电信业务经营许可证 B1-20180288&nbsp;&nbsp;<span>·</span>&nbsp;&nbsp;浙ICP备17006647号-2&nbsp;&nbsp;<span>·</span>&nbsp;&nbsp;杭州市滨江区网商路599号网易大厦</p><p><i class="m-footer-info-icon"></i><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010802008718" class="m-footer-info-police" target="_blank" data-pageid="index">浙公网安备 33010802008718号</a></p></footer></div><div class="toTop"><a href="javascript:void(0);" id="commonHelpContentTop" class="help"><i class="icon-down"></i></a></div><script type="text/javascript">window.passportUrl = 'https://id.163yun.com';window.baseUrl = 'https://sq.163yun.com';window.homesiteUrl = 'https://www.163yun.com';</script><script src="https://id.163yun.com/sdk/nep-0.1.1.min.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}();</script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-110853334-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-110853334-1");</script><!-- HUBBLE SDK --><script src="https://hubble-js-bucket.nosdn.127.net/DATracker.sync.1.4.0.js"></script><script>DATracker.init("MA-91DF-2127272A00D5");</script><script type="text/javascript">window.articleId = '200743376636538880';</script><script type="text/javascript" src="/js/vendors.js?e66f8211b5d927468305"></script><script type="text/javascript" src="/js/blog/article.js?e66f8211b5d927468305"></script></body></html>