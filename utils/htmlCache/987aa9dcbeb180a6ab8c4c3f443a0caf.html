<!DOCTYPE html>
<html>
  <head>
    <title>@dynamicCallable: Unix Tools as Swift Functions ‚Äì The Always Right Institute ‚Äì Almost always sometimes definitely right.</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="A new feature in Swift 5 are
Dynamic Callable‚Äôs.
We combine this with the related
Dynamic Member Lookup
feature to expose the filesystem and Unix shell commands as
regular Swift objects and functions.

" />
    <meta property="og:description" content="A new feature in Swift 5 are
Dynamic Callable‚Äôs.
We combine this with the related
Dynamic Member Lookup
feature to expose the filesystem and Unix shell commands as
regular Swift objects and functions.

" />
    
    <meta name="author" content="The Always Right Institute" />

    
    <meta property="og:title" content="@dynamicCallable: Unix Tools as Swift Functions" />
    <meta property="twitter:title" content="@dynamicCallable: Unix Tools as Swift Functions" />
    

    
    <meta property="article:tag" content="swift" />
    
    <meta property="article:tag" content="process" />
    
    <meta property="article:tag" content="dynamicCallable" />
    


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="The Always Right Institute - Almost always sometimes definitely right." href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
    
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://pbs.twimg.com/profile_images/639743704429785088/S3ABe3uX.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">The Always Right Institute</a></h1>
            <p class="site-description">Almost always sometimes definitely right.</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>@dynamicCallable: Unix Tools as Swift Functions</h1>

  <div class="entry">
    <p>A new feature in Swift 5 are
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md">Dynamic Callable</a>‚Äôs.
We combine this with the related
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">Dynamic Member Lookup</a>
feature to expose the filesystem and Unix shell commands as
regular Swift objects and functions.</p>

<p>Wait what?! We want to call arbitrary commandline tools from
within Swift, like so:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Shell</span>

<span class="k">for</span> <span class="n">file</span> <span class="k">in</span> <span class="n">shell</span><span class="o">.</span><span class="nf">ls</span><span class="p">(</span><span class="s">"/Users/"</span><span class="p">)</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dir:"</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// dir: Guest</span>
<span class="c1">// dir: Shared</span>
<span class="c1">// dir: helge</span>

<span class="k">let</span> <span class="nv">swiftVersion</span> <span class="o">=</span> <span class="n">shell</span><span class="o">.</span><span class="nf">swift</span><span class="p">(</span><span class="s">"--version"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">swiftVersion</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">.</span><span class="n">first</span> <span class="p">??</span> <span class="s">""</span><span class="p">)</span>
<span class="c1">// Apple Swift version 5.0-dev (LLVM fe02928dd1, Clang 8836e4e85c, Swift 468f5b0530)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">shell</span><span class="o">.</span><span class="n">usr</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">bin</span><span class="o">.</span><span class="nf">python</span><span class="p">(</span><span class="s">"-c"</span><span class="p">,</span> <span class="s">"'print(13 + 37)'"</span><span class="p">))</span>
<span class="c1">// 42</span>
</code></pre></div></div>

<p>Inspired by the Python <a href="https://amoffat.github.io/sh/">sh</a> module,
any executable tool, from <code class="highlighter-rouge">at</code> to <code class="highlighter-rouge">xsltproc</code>, is made available as a
first class Swift function. Magic ü¶Ñ.</p>

<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md">Dynamic Callable</a>
essentially allows you to turn any type into a regular Swift ‚Äúfunction‚Äù.
Let‚Äôs see how this works!</p>

<p>You can follow along, or you can go ahead and 
<a href="https://github.com/AlwaysRightInstitute/Shell">grab <code class="highlighter-rouge">Shell</code> from GitHub</a>.</p>

<p><strong>Important</strong>: Remember that you need to have Swift 5 via 
<a href="https://developer.apple.com/xcode/">Xcode 10.2</a>.</p>

<h2 id="se-0195-dynamic-member-lookup">SE-0195: Dynamic Member Lookup</h2>

<p>Before we jump into the new dynamic callable feature, let us revisit the
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">Dynamic Member Lookup</a>
introduced in Swift 4.2. Environment variable lookup is the default example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@dynamicMemberLookup</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">EnvironmentTrampoline</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="nf">subscript</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">k</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">ProcessInfo</span><span class="o">.</span><span class="n">processInfo</span><span class="o">.</span><span class="n">environment</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">env</span> <span class="o">=</span> <span class="kt">EnvironmentTrampoline</span><span class="p">()</span>

<span class="k">let</span> <span class="nv">path</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="kt">PATH</span> <span class="p">??</span> <span class="s">""</span> <span class="c1">// retrieve an env variable</span>
</code></pre></div></div>

<p>So what this does is instead of having to write:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env</span><span class="p">[</span><span class="s">"PATH"</span><span class="p">]</span>
</code></pre></div></div>
<p>you can directly use that key like:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env</span><span class="o">.</span><span class="kt">PATH</span>
</code></pre></div></div>
<p>When the compiler tries to lookup the <code class="highlighter-rouge">PATH</code> ‚Äúmember‚Äù, it doesn‚Äôt find that
in our struct. Usually that would result in a compile time error.
But if the compiler sees that the type is marked up as <code class="highlighter-rouge">@dynamicMemberLookup</code>,
it will instead replace the <code class="highlighter-rouge">env.PATH</code> with this call:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env</span><span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"PATH"</span><span class="p">]</span>
</code></pre></div></div>

<p>The environment example isn‚Äôt very exciting, but this also allows you to
traverse nested structures, for example a generic JSON dictionary:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">json</span><span class="o">.</span><span class="n">person</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">street</span>
<span class="c1">// rewritten to:</span>
<span class="n">json</span><span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"person"</span><span class="p">][</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"address"</span><span class="p">][</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"street"</span><span class="p">]</span>
</code></pre></div></div>

<p>In our case, we use this feature for two things:</p>
<ol>
  <li>to navigate the filesystem</li>
  <li>to dynamically lookup tools in the <code class="highlighter-rouge">$PATH</code></li>
</ol>

<h3 id="navigate-the-filesystem-in-swift">Navigate the FileSystem in Swift</h3>

<p>In the spirit of the Environment example above, 
let us create a trampoline which allows us to traverse the
filesystem using just Swift <code class="highlighter-rouge">a.b.c</code> syntax:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@dynamicMemberLookup</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">ShellPathTrampoline</span> <span class="p">{</span>
  
    <span class="k">let</span> <span class="nv">url</span> <span class="p">:</span> <span class="kt">URL</span>
    <span class="k">var</span> <span class="nv">fm</span>  <span class="p">:</span> <span class="kt">FileManager</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span> <span class="p">}</span>
  
    <span class="kd">public</span> <span class="nf">subscript</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> 
           <span class="o">-&gt;</span> <span class="kt">ShellPathTrampoline</span> 
    <span class="p">{</span>
        <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">url</span><span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">!</span><span class="nf">isDirectory</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">url</span> <span class="p">}</span>
            <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="n">url</span><span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nv">isDirectory</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
        <span class="p">}()</span>
        <span class="k">return</span> <span class="kt">ShellPathTrampoline</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">isDirectory</span><span class="p">(</span><span class="n">_</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">isDir</span>  <span class="p">:</span> <span class="kt">ObjCBool</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="k">let</span> <span class="nv">exists</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="nf">fileExists</span><span class="p">(</span><span class="nv">atPath</span><span class="p">:</span> <span class="n">url</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="nv">isDirectory</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">isDir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">exists</span> <span class="o">&amp;&amp;</span> <span class="n">isDir</span><span class="o">.</span><span class="n">boolValue</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">fsRoot</span> <span class="o">=</span> <span class="kt">ShellPathTrampoline</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">fileURLWithPath</span><span class="p">:</span> <span class="s">"/"</span><span class="p">))</span>

<span class="nf">print</span><span class="p">(</span><span class="n">fsRoot</span><span class="o">.</span><span class="n">usr</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">bin</span><span class="o">.</span><span class="n">python</span><span class="p">)</span> <span class="c1">// &lt;==</span>
<span class="c1">// ShellPathTrampoline(url: file:///usr/local/bin/python)</span>
</code></pre></div></div>

<p>Note how we give the path using dot syntax: <code class="highlighter-rouge">usr.local.bin.python</code> which
is translated to:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fsRoot</span><span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"usr"</span><span class="p">]</span>    <span class="c1">// yields the usr trampoline</span>
      <span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"local"</span><span class="p">]</span>  <span class="c1">// appends "local" to "usr"</span>
      <span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"bin"</span><span class="p">]</span>    <span class="c1">// and then "bin"</span>
      <span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"python"</span><span class="p">]</span> <span class="c1">// .. you get it</span>
</code></pre></div></div>

<p>The code of our <code class="highlighter-rouge">subscript</code> looks a little complicated, which is mainly
due to the Foundation API to detect a directory being a little awkward
(and we need that to append a proper ending ‚Äú<code class="highlighter-rouge">/</code>‚Äù to the URL, e.g. ‚Äú<code class="highlighter-rouge">/usr/</code>‚Äù).</p>

<p>In short: This is just a simple, but Swift-integrated, URL builder.</p>

<h3 id="do-path-lookups">Do <code class="highlighter-rouge">$PATH</code> lookups</h3>

<p>This is already quite nice, but we also want to find tools by traversing the
<code class="highlighter-rouge">$PATH</code> - if necessary. I.e. instead of having to call <code class="highlighter-rouge">shell.usr.bin.ls</code>,
we also want this shortcut to work: <code class="highlighter-rouge">shell.ls</code>.</p>

<p>Let‚Äôs add another trampoline which can do the dynamic lookup:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ShellPathTrampoline</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">doesExist</span> <span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fm</span><span class="o">.</span><span class="nf">fileExists</span><span class="p">(</span><span class="nv">atPath</span><span class="p">:</span> <span class="n">url</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@dynamicMemberLookup</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">ShellTrampoline</span> <span class="p">{</span>
  
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">root</span> <span class="p">:</span> <span class="kt">ShellPathTrampoline</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">url</span>  <span class="p">:</span> <span class="kt">URL</span> <span class="p">{</span> <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">url</span> <span class="p">}</span>
  
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">fileURLWithPath</span><span class="p">:</span> <span class="s">"/"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kt">ShellPathTrampoline</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
    <span class="p">}</span>
  
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">environment</span> <span class="o">=</span> <span class="kt">EnvironmentTrampoline</span><span class="p">()</span>
  
    <span class="kd">public</span> <span class="nf">subscript</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> 
           <span class="o">-&gt;</span> <span class="kt">ShellPathTrampoline</span> 
    <span class="p">{</span>
        <span class="k">let</span> <span class="nv">trampoline</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">trampoline</span><span class="o">.</span><span class="n">doesExist</span> <span class="p">{</span> <span class="k">return</span> <span class="n">trampoline</span> <span class="p">}</span>
        <span class="k">return</span> <span class="nf">lookupInPATH</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">??</span> <span class="n">trampoline</span>
    <span class="p">}</span>
  
    <span class="kd">func</span> <span class="nf">lookupInPATH</span><span class="p">(</span><span class="n">_</span> <span class="nv">k</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ShellPathTrampoline</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">searchPath</span> <span class="o">=</span> <span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="kt">PATH</span> <span class="p">??</span> <span class="s">"/usr/bin"</span><span class="p">)</span>
                         <span class="o">.</span><span class="nf">components</span><span class="p">(</span><span class="nv">separatedBy</span><span class="p">:</span> <span class="s">":"</span><span class="p">)</span>
      
        <span class="k">let</span> <span class="nv">testURLs</span> <span class="o">=</span> <span class="n">searchPath</span><span class="o">.</span><span class="kd">lazy</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> 
            <span class="p">(</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">URL</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">testDirURL</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">fileURLWithPath</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span> <span class="nv">relativeTo</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">testDirURL</span><span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="p">}</span>
      
        <span class="k">let</span> <span class="nv">fm</span> <span class="o">=</span> <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span>
        <span class="k">for</span> <span class="n">testURL</span> <span class="k">in</span> <span class="n">testURLs</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">testPath</span> <span class="o">=</span> <span class="n">testURL</span><span class="o">.</span><span class="n">path</span>
            <span class="k">var</span> <span class="nv">isDir</span>    <span class="p">:</span> <span class="kt">ObjCBool</span> <span class="o">=</span> <span class="kc">false</span>
          
            <span class="k">if</span> <span class="n">fm</span><span class="o">.</span><span class="nf">fileExists</span><span class="p">(</span><span class="nv">atPath</span><span class="p">:</span> <span class="n">testPath</span><span class="p">,</span> <span class="nv">isDirectory</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">isDir</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="n">isDir</span><span class="o">.</span><span class="n">boolValue</span> <span class="o">&amp;&amp;</span> <span class="n">fm</span><span class="o">.</span><span class="nf">isExecutableFile</span><span class="p">(</span><span class="nv">atPath</span><span class="p">:</span> <span class="n">testPath</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kt">ShellPathTrampoline</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">testURL</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="k">let</span> <span class="nv">shell</span> <span class="o">=</span> <span class="kt">ShellTrampoline</span><span class="p">()</span>

<span class="nf">print</span><span class="p">(</span><span class="n">shell</span><span class="o">.</span><span class="n">python</span><span class="p">)</span>
<span class="c1">// ShellPathTrampoline(url: file:///usr/bin/python)</span>
</code></pre></div></div>

<p>Notice how the simple <code class="highlighter-rouge">shell.python</code> is expanded to the full path:
<code class="highlighter-rouge">/usr/bin/python</code>.</p>

<p>This trampoline accepts absolute pathes in the <code class="highlighter-rouge">dynamicMember</code> subscript.
If the path passed-in does not exist, it will search the lookup pathes
stored in the <code class="highlighter-rouge">$PATH</code> environment variable
(usually looks like <code class="highlighter-rouge">/usr/local/bin:/usr/bin:/sbin</code>),
using the <code class="highlighter-rouge">lookupInPATH</code> function (notice how we use our <code class="highlighter-rouge">environment</code>
trampoline from above to access <code class="highlighter-rouge">PATH</code>).</p>

<h3 id="summary-dynamic-member-lookup">Summary: Dynamic Member Lookup</h3>

<p>We‚Äôve shown how you can use Swift dot syntax to lookup values dynamically.
And by that, we built a way to construct and even lookup filesystem pathes.
But so far, we can‚Äôt really do anything with those <code class="highlighter-rouge">ShellPathTrampoline</code>
values we get.</p>

<p>Remember that the compiler just rewrites this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shell</span><span class="o">.</span><span class="n">python</span>
</code></pre></div></div>
<p>into this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shell</span><span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"python"</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="se-0216-dynamic-callable">SE-0216: Dynamic Callable</h2>

<p>So lets approach 
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md">Dynamic Callable</a>.
Again, there is actually very little magic involved.
Let us assume our <code class="highlighter-rouge">shell.swift</code> returns us a <code class="highlighter-rouge">ShellPathTrampoline</code> struct.
That struct is obviously not a function and if we try to do this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shell</span><span class="o">.</span><span class="nf">swift</span><span class="p">()</span>
</code></pre></div></div>
<p>The compiler will rightfully complain:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cannot call value of non-function type 'ShellPathTrampoline'
</code></pre></div></div>

<p>This is where 
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md">Dynamic Callable</a>
steps in. It allows us to turn a <code class="highlighter-rouge">non-function type</code> into a <code class="highlighter-rouge">function type</code>
by adding the <code class="highlighter-rouge">@dynamicCallable</code> attribute to the struct. Let‚Äôs do this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@dynamicCallable</span>     <span class="c1">// &lt;== add this!</span>
<span class="kd">@dynamicMemberLookup</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">ShellPathTrampoline</span> <span class="p">{</span>
    <span class="o">...</span> <span class="n">code</span> <span class="n">from</span> <span class="n">above</span> <span class="o">...</span>

    <span class="kd">@discardableResult</span>
    <span class="kd">func</span> <span class="nf">dynamicallyCall</span><span class="p">(</span><span class="n">withArguments</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span> <span class="kt">String</span> <span class="p">])</span>
         <span class="o">-&gt;</span> <span class="kt">Process</span><span class="o">.</span><span class="kt">FancyResult</span>
    <span class="p">{</span>
        <span class="c1">// some error handling in the real module here</span>
        <span class="k">return</span> <span class="kt">Process</span><span class="o">.</span><span class="nf">launch</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">url</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">arguments</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">shell</span><span class="o">.</span><span class="nf">swift</span><span class="p">(</span><span class="s">"--version"</span><span class="p">))</span>
<span class="c1">// Apple Swift version 4.2.1 (swiftlang-1000.11.42 clang-1000.11.45.1)</span>
<span class="c1">// Targ...</span>
</code></pre></div></div>

<blockquote>
  <p>You can‚Äôt add <code class="highlighter-rouge">@dynamicCallable</code> or <code class="highlighter-rouge">@dynamicMemberLookup</code>
in an extension, it has to be defined in the basetype.
The code also omits a helper extension on
<a href="https://developer.apple.com/documentation/foundation/process"><code class="highlighter-rouge">Process</code></a>,
which you can find in the
<a href="https://github.com/AlwaysRightInstitute/Shell/blob/master/Sources/Shell/ProcessHelper.swift">GitHub repo</a>.</p>
</blockquote>

<p>When the Swift compiler sees this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shell</span><span class="o">.</span><span class="nf">swift</span><span class="p">(</span><span class="s">"--version"</span><span class="p">)</span>
</code></pre></div></div>
<p>it is about to emit the cannot-call error above, but because our type
is marked as <code class="highlighter-rouge">@dynamicCallable</code>, it is instead going to rewrite this
into:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shell</span><span class="o">.</span><span class="n">swift</span><span class="o">.</span><span class="nf">dynamicallyCall</span><span class="p">(</span><span class="nv">withArguments</span><span class="p">:</span> <span class="p">[</span> <span class="s">"--version"</span> <span class="p">])</span>
</code></pre></div></div>
<p>And since <code class="highlighter-rouge">.swift</code> is looked up dynamically, the whole thing looks like this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shell</span><span class="p">[</span><span class="nv">dynamicMember</span><span class="p">:</span> <span class="s">"swift"</span><span class="p">]</span>
     <span class="o">.</span><span class="nf">dynamicallyCall</span><span class="p">(</span><span class="nv">withArguments</span><span class="p">:</span> <span class="p">[</span> <span class="s">"--version"</span> <span class="p">])</span>
</code></pre></div></div>

<p>Our implementation of <code class="highlighter-rouge">dynamicallyCall</code> gets the URL to the tool as part
of the lookup process (<code class="highlighter-rouge">file:///usr/bin/swift</code>).<br />
It then just forks this tool using <code class="highlighter-rouge">Process.launch(at: url, with: args)</code>
and returns with the result (another helper object containing the tools
exit status, plus the command output and error data emitted).</p>

<p>In short: We just turned a Unix commandline tool into a Swift function
with minimal effort. 
Now we can do all the fancy stuff we wanted above, like:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">file</span> <span class="k">in</span> <span class="n">shell</span><span class="o">.</span><span class="nf">ls</span><span class="p">(</span><span class="s">"/Users/"</span><span class="p">)</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dir:"</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// dir: Guest</span>
<span class="c1">// dir: Shared</span>
<span class="c1">// dir: helge</span>
</code></pre></div></div>

<p>As you can see <code class="highlighter-rouge">@dynamicCallable</code> and <code class="highlighter-rouge">@dynamicMemberLookup</code> combine
beautifully, and doing so increases their usefulness a lot.<br />
Imagine how your SQL library could dynamically lookup a stored procedure
(or <code class="highlighter-rouge">EOFetchSpecification</code>) and run it, 
just by using <code class="highlighter-rouge">db.processPendingOrders()</code>.</p>

<h2 id="finished-shell-swift-package">Finished Shell Swift Package</h2>

<p>A few words of warning:
This is intended as a demo. 
It should work just fine, but in the name of error handling and proper Swift
beauty, 
you might want to approach forking processes differently ü§ì
(BTW: PRs are welcome!)</p>

<h3 id="sample-tool-using-the-shell-package">Sample tool using the Shell package</h3>

<p>The regular Swift Package Manager setup process:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir ShellConsumerTest <span class="o">&amp;&amp;</span> <span class="nb">cd </span>ShellConsumerTest
swift package init <span class="nt">--type</span> executable
</code></pre></div></div>

<p>Sample <code class="highlighter-rouge">main.swift</code>, calling the <code class="highlighter-rouge">host</code> tool (located in <code class="highlighter-rouge">/usr/bin</code>):</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Shell</span>

<span class="nf">print</span><span class="p">(</span><span class="n">shell</span><span class="o">.</span><span class="nf">host</span><span class="p">(</span><span class="s">"zeezide.de"</span><span class="p">))</span>
</code></pre></div></div>

<p>Sample <code class="highlighter-rouge">Package.swift</code>:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// swift-tools-version:5.0</span>

<span class="kd">import</span> <span class="kt">PackageDescription</span>

<span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"ShellConsumerTest"</span><span class="p">,</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">package</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="s">"https://github.com/AlwaysRightInstitute/Shell.git"</span><span class="p">,</span>
                 <span class="nv">from</span><span class="p">:</span> <span class="s">"0.1.0"</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"ShellConsumerTest"</span><span class="p">,</span>
                <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span> <span class="s">"Shell"</span> <span class="p">]),</span> <span class="c1">// &lt;= do not forget!</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>
<p>Remember to add the dependency in two places. WET is best!</p>

<blockquote>
  <p><code class="highlighter-rouge">swift run</code> and <code class="highlighter-rouge">swift test</code> patch the <code class="highlighter-rouge">$PATH</code> to just <code class="highlighter-rouge">/usr/bin</code>. You
may want to run the binary directly to make lookup work properly.</p>
</blockquote>

<h2 id="origins-python">Origins: Python</h2>

<p>Congratulations! 
Now that you understand 
<code class="highlighter-rouge">@dynamicCallable</code> and <code class="highlighter-rouge">@dynamicMemberLookup</code>
you essentially turned into a Python-Pro!
It is roughly how Python implements functions, methods and objects
in its runtime.</p>

<p>It is common knowledge that the features were added so that Google could
integrate Python machine learning libraries neatly into Swift.
But there is more to the feature, in fact Python itself has ‚Äúalways‚Äù had the
same feature:
<a href="https://docs.python.org/2/reference/datamodel.html#object.__getattr__"><code class="highlighter-rouge">___getattr___</code></a>
and
<a href="https://docs.python.org/2/reference/datamodel.html#emulating-callable-objects"><code class="highlighter-rouge">___call___</code></a>.</p>

<p>Python is the first time we‚Äôve seen the <code class="highlighter-rouge">Callable</code> concept. In Python every
call like</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db</span><span class="o">.</span><span class="n">processPendingOrders</span><span class="p">()</span>
</code></pre></div></div>
<p>is essentially a ‚Äúproperty get‚Äù which returns a (potentially self-bound)
‚Äúcallable‚Äù, which is then being called.
This is pretty different to other languages which often directly invoke
a method, or pass it through a message dispatcher.
(In Objective-C you could always do the same shown here using
 <code class="highlighter-rouge">forwardInvocation:</code> and friends.)</p>

<h2 id="limitations">Limitations</h2>

<p>An obvious limitation is that both features are statically typed. 
You can‚Äôt lookup one function thats returns an Int, and another function 
which returns a String. You have to tell the compiler in advance what type
you expect.<br />
In practice this is probably going to end up in a lot of <code class="highlighter-rouge">Any</code>s / <code class="highlighter-rouge">as?</code> / <code class="highlighter-rouge">is</code>
when this feature is being used. Time will show.</p>

<p>Another limitation is that the reverse is not possible, i.e. you cannot 
lookup a Callable for a Swift function and dynamically invoke it via
<code class="highlighter-rouge">m.dynamicallyCall(withArguments:)</code>. Aka reflection.</p>

<p>At least the current implementation doesn‚Äôt seem to support overloading, i.e.
you can‚Äôt have this:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@dynamicCallable</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">MyCallable</span> <span class="p">{</span>
  <span class="kd">@discardableResult</span>
  <span class="kd">func</span> <span class="nf">dynamicallyCall</span><span class="p">(</span><span class="n">withArguments</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span> <span class="kt">Int</span> <span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arguments</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">@discardableResult</span>
  <span class="kd">func</span> <span class="nf">dynamicallyCall</span><span class="p">(</span><span class="n">withArguments</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span> <span class="kt">Any</span> <span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arguments</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span> <span class="p">}</span><span class="o">.</span><span class="nf">joined</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">","</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">call</span> <span class="o">=</span> <span class="kt">MyCallable</span><span class="p">()</span>
<span class="n">call</span><span class="o">.</span><span class="nf">ints</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">call</span><span class="o">.</span><span class="nf">joined</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p>You can‚Äôt mix types, all arguments have to be the same type. I.e. this is
not possible:</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@discardableResult</span>
<span class="kd">func</span> <span class="nf">dynamicallyCall</span><span class="p">(</span><span class="nv">arg1</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">arg2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> 
</code></pre></div></div>

<p>Or this, which is specifically annoying for APIs (though this goes away a
little with async/await):</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@discardableResult</span>
<span class="kd">func</span> <span class="n">dynamicallyCall</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">withArguments</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span> <span class="kt">Any</span> <span class="p">],</span> <span class="nv">yield</span><span class="p">:</span> <span class="p">(</span> <span class="kt">T</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="streaming-and-async-io">Streaming and Async I/O</h2>

<p>Using this library in server side code is not recommended, it is blocking and
the stdout/err/in processing is not streaming. 
(Also: do I have to talk about the security implications of doing such stuff
 on the server? I hope not üòé)</p>

<p>An example on how to do this properly can be found in 
<a href="http://noze.io/noze4nonnode/">Noze.io</a>,
which provides piping, backpressure aware streams, etc:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="nf">spawn</span><span class="p">(</span><span class="s">"git"</span><span class="p">,</span> <span class="s">"log"</span><span class="p">,</span> <span class="s">"-100"</span><span class="p">,</span> <span class="s">"--pretty=format:%H|%an|&lt;%ae&gt;|%ad"</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">readlines</span>
  <span class="o">|</span> <span class="nf">through2</span><span class="p">(</span><span class="n">linesToRecords</span><span class="p">)</span>
  <span class="o">|</span> <span class="nf">through2</span><span class="p">(</span><span class="n">recordsToHTML</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">response</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>Those two are pretty exciting features and we are looking forward what people
are going to do with them!</p>

<p>The code didn‚Äôt have any <a href="https://github.com/AlwaysRightInstitute/cows">cows</a>,
so let‚Äôs at least have this one: üêÑ</p>

<h3 id="links">Links</h3>

<ul>
  <li><a href="http://www.alwaysrightinstitute.com/swift-objc-bridge/">@dynamicCallable Part 2: Swift/ObjC Bridge</a>,</li>
  <li><a href="http://www.alwaysrightinstitute.com/mustachable/">@dynamicCallable Part 3: Mustacheable</a>,</li>
  <li><a href="https://github.com/AlwaysRightInstitute/Shell">Shell module</a> on GitHub</li>
  <li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">SE-0195 Dynamic Member Lookup</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md">SE-0216 Dynamic Callable</a></li>
  <li>Python <a href="https://amoffat.github.io/sh/">sh module</a></li>
  <li><a href="http://noze.io/">Noze.io</a></li>
</ul>

  </div>

  <div class="date">
    Written on December 21, 2018
  </div>
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:wrong@alwaysrightinstitute.com"><i class="svg-icon email"></i></a>


<a href="https://github.com/AlwaysRightInstitute"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/ar_institute"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
